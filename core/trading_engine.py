"""Core trading engine for DEGIRO trading agent.

This module implements the main trading engine that:
- Monitors portfolio and market conditions
- Evaluates trading rules
- Executes trades with risk management
- Manages order lifecycle
- Provides trading analytics
"""

import asyncio
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
from dataclasses import dataclass
from decimal import Decimal

from core.logging_config import get_logger
from core.models import (
    Portfolio, Position, Order, OrderType, OrderSide, OrderStatus,
    Product, Transaction, TransactionType
)
from core.portfolio_service import PortfolioService
from core.degiro_api import degiro_api
from core.config import config_manager
from core.database import get_db_session
from core.data_persistence import data_persistence
from core.exceptions import TradingEngineError, RiskManagementError


logger = get_logger("trading_engine")


class EngineState(str, Enum):
    """Trading engine states."""
    STOPPED = "STOPPED"
    STARTING = "STARTING"
    RUNNING = "RUNNING"
    PAUSED = "PAUSED"
    ERROR = "ERROR"
    EMERGENCY_STOP = "EMERGENCY_STOP"


class RuleType(str, Enum):
    """Types of trading rules."""
    PRICE_TARGET = "PRICE_TARGET"
    PERCENTAGE_CHANGE = "PERCENTAGE_CHANGE"
    TECHNICAL_INDICATOR = "TECHNICAL_INDICATOR"
    PORTFOLIO_ALLOCATION = "PORTFOLIO_ALLOCATION"
    TIME_BASED = "TIME_BASED"
    VOLUME_BASED = "VOLUME_BASED"
    RISK_MANAGEMENT = "RISK_MANAGEMENT"


class RiskCheckType(str, Enum):
    """Types of risk checks."""
    POSITION_SIZE = "POSITION_SIZE"
    ACCOUNT_BALANCE = "ACCOUNT_BALANCE"
    DAILY_LOSS_LIMIT = "DAILY_LOSS_LIMIT"
    CONCENTRATION_LIMIT = "CONCENTRATION_LIMIT"
    VOLATILITY_CHECK = "VOLATILITY_CHECK"
    MARKET_HOURS = "MARKET_HOURS"


@dataclass
class TradingRule:
    """Trading rule definition."""
    id: str
    name: str
    rule_type: RuleType
    product_id: str
    conditions: Dict[str, Any]
    action: Dict[str, Any]
    priority: int = 1
    enabled: bool = True
    created_at: datetime = None
    last_triggered: Optional[datetime] = None
    trigger_count: int = 0
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()


@dataclass
class RiskCheck:
    """Risk check definition."""
    check_type: RiskCheckType
    parameters: Dict[str, Any]
    enabled: bool = True


@dataclass
class TradingSignal:
    """Trading signal generated by rules."""
    rule_id: str
    product_id: str
    action: str  # BUY, SELL, HOLD
    quantity: float
    price: Optional[float] = None
    order_type: OrderType = OrderType.MARKET
    confidence: float = 1.0
    reason: str = ""
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class TradingEngine:
    """Main trading engine class."""
    
    def __init__(self):
        self.state = EngineState.STOPPED
        self.portfolio_service = PortfolioService()
        self.api = degiro_api
        
        # Trading rules and risk management
        self.trading_rules: Dict[str, TradingRule] = {}
        self.risk_checks: List[RiskCheck] = []
        self.pending_orders: Dict[str, Order] = {}
        self.active_signals: List[TradingSignal] = []
        
        # Configuration
        self.config = {
            "max_daily_trades": 10,
            "max_position_size_pct": 10.0,  # Max 10% of portfolio per position
            "max_daily_loss_pct": 5.0,      # Max 5% daily loss
            "risk_free_cash_pct": 10.0,     # Keep 10% cash
            "enable_paper_trading": True,    # Start in paper trading mode
            "order_timeout_minutes": 30,
            "price_tolerance_pct": 2.0,     # 2% price tolerance for limit orders
        }
        
        # Statistics
        self.stats = {
            "trades_today": 0,
            "daily_pnl": 0.0,
            "total_trades": 0,
            "successful_trades": 0,
            "failed_trades": 0,
            "last_trade_time": None,
            "engine_start_time": None
        }
        
        # Load configuration
        self._load_configuration()
        self._initialize_default_risk_checks()
        
        logger.info("Trading engine initialized")
    
    def _load_configuration(self):
        """Load trading engine configuration."""
        try:
            engine_config = config_manager.get("trading_engine", {})
            self.config.update(engine_config)
            logger.info(f"Loaded trading engine configuration: {self.config}")
        except Exception as e:
            logger.warning(f"Failed to load trading engine config: {e}")
    
    def _initialize_default_risk_checks(self):
        """Initialize default risk management checks."""
        self.risk_checks = [
            RiskCheck(
                check_type=RiskCheckType.POSITION_SIZE,
                parameters={"max_position_pct": self.config["max_position_size_pct"]}
            ),
            RiskCheck(
                check_type=RiskCheckType.ACCOUNT_BALANCE,
                parameters={"min_cash_pct": self.config["risk_free_cash_pct"]}
            ),
            RiskCheck(
                check_type=RiskCheckType.DAILY_LOSS_LIMIT,
                parameters={"max_loss_pct": self.config["max_daily_loss_pct"]}
            ),
            RiskCheck(
                check_type=RiskCheckType.MARKET_HOURS,
                parameters={"trading_hours": {"start": "09:00", "end": "17:30"}}
            )
        ]
        logger.info(f"Initialized {len(self.risk_checks)} default risk checks")
    
    async def start(self) -> bool:
        """Start the trading engine."""
        try:
            logger.info("Starting trading engine...")
            self.state = EngineState.STARTING
            
            # Verify API connection
            if not self.api.is_connected:
                if not self.api.connect():
                    raise TradingEngineError("Failed to connect to DEGIRO API")
            
            # Initialize portfolio data
            portfolio = self.portfolio_service.get_portfolio(force_refresh=True)
            if not portfolio:
                raise TradingEngineError("Failed to fetch initial portfolio data")
            
            # Reset daily statistics
            self._reset_daily_stats()
            
            self.state = EngineState.RUNNING
            self.stats["engine_start_time"] = datetime.now()
            
            logger.info("Trading engine started successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start trading engine: {e}")
            self.state = EngineState.ERROR
            return False
    
    def stop(self):
        """Stop the trading engine."""
        logger.info("Stopping trading engine...")
        self.state = EngineState.STOPPED
        
        # Cancel pending orders
        self._cancel_all_pending_orders()
        
        logger.info("Trading engine stopped")
    
    def pause(self):
        """Pause the trading engine."""
        logger.info("Pausing trading engine...")
        self.state = EngineState.PAUSED
    
    def resume(self):
        """Resume the trading engine."""
        logger.info("Resuming trading engine...")
        if self.state == EngineState.PAUSED:
            self.state = EngineState.RUNNING
    
    def emergency_stop(self):
        """Emergency stop - immediately halt all trading."""
        logger.critical("EMERGENCY STOP activated!")
        self.state = EngineState.EMERGENCY_STOP
        
        # Cancel all pending orders
        self._cancel_all_pending_orders()
        
        # Clear active signals
        self.active_signals.clear()
    
    def add_trading_rule(self, rule: TradingRule) -> bool:
        """Add a new trading rule."""
        try:
            # Validate rule
            if not self._validate_trading_rule(rule):
                return False
            
            self.trading_rules[rule.id] = rule
            logger.info(f"Added trading rule: {rule.name} ({rule.id})")
            
            # Save to database
            self._save_trading_rule(rule)
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to add trading rule: {e}")
            return False
    
    def remove_trading_rule(self, rule_id: str) -> bool:
        """Remove a trading rule."""
        if rule_id in self.trading_rules:
            rule = self.trading_rules.pop(rule_id)
            logger.info(f"Removed trading rule: {rule.name} ({rule_id})")
            return True
        return False
    
    def enable_rule(self, rule_id: str) -> bool:
        """Enable a trading rule."""
        if rule_id in self.trading_rules:
            self.trading_rules[rule_id].enabled = True
            logger.info(f"Enabled trading rule: {rule_id}")
            return True
        return False
    
    def disable_rule(self, rule_id: str) -> bool:
        """Disable a trading rule."""
        if rule_id in self.trading_rules:
            self.trading_rules[rule_id].enabled = False
            logger.info(f"Disabled trading rule: {rule_id}")
            return True
        return False
    
    async def process_trading_cycle(self) -> List[TradingSignal]:
        """Process one trading cycle - evaluate rules and generate signals."""
        if self.state != EngineState.RUNNING:
            return []
        
        try:
            logger.debug("Processing trading cycle...")
            
            # Get current portfolio
            portfolio = self.portfolio_service.get_portfolio()
            if not portfolio:
                logger.warning("No portfolio data available")
                return []
            
            # Evaluate all enabled trading rules
            signals = []
            for rule in self.trading_rules.values():
                if rule.enabled:
                    signal = await self._evaluate_rule(rule, portfolio)
                    if signal:
                        signals.append(signal)
            
            # Process signals
            processed_signals = []
            for signal in signals:
                if await self._process_trading_signal(signal, portfolio):
                    processed_signals.append(signal)
            
            self.active_signals.extend(processed_signals)
            
            logger.debug(f"Generated {len(processed_signals)} trading signals")
            return processed_signals
            
        except Exception as e:
            logger.error(f"Error in trading cycle: {e}")
            return []
    
    async def _evaluate_rule(self, rule: TradingRule, portfolio: Portfolio) -> Optional[TradingSignal]:
        """Evaluate a single trading rule."""
        try:
            # Find the position for this product
            position = None
            for pos in portfolio.positions:
                if pos.product_id == rule.product_id:
                    position = pos
                    break
            
            # Evaluate based on rule type
            if rule.rule_type == RuleType.PRICE_TARGET:
                return await self._evaluate_price_target_rule(rule, position)
            elif rule.rule_type == RuleType.PERCENTAGE_CHANGE:
                return await self._evaluate_percentage_change_rule(rule, position)
            elif rule.rule_type == RuleType.PORTFOLIO_ALLOCATION:
                return await self._evaluate_allocation_rule(rule, portfolio, position)
            elif rule.rule_type == RuleType.RISK_MANAGEMENT:
                return await self._evaluate_risk_management_rule(rule, portfolio, position)
            
            # Add more rule types as needed
            
        except Exception as e:
            logger.error(f"Error evaluating rule {rule.id}: {e}")
        
        return None
    
    async def _evaluate_price_target_rule(self, rule: TradingRule, position: Optional[Position]) -> Optional[TradingSignal]:
        """Evaluate price target rule."""
        conditions = rule.conditions
        action_config = rule.action
        
        if not position or not position.current_price:
            return None
        
        current_price = position.current_price
        target_price = conditions.get("target_price")
        action_type = conditions.get("action", "sell")  # sell when target reached
        
        if not target_price:
            return None
        
        # Check if target is reached
        if action_type == "sell" and current_price >= target_price:
            return TradingSignal(
                rule_id=rule.id,
                product_id=rule.product_id,
                action="SELL",
                quantity=action_config.get("quantity", position.size),
                order_type=OrderType.LIMIT,
                price=target_price,
                reason=f"Price target {target_price} reached (current: {current_price})"
            )
        elif action_type == "buy" and current_price <= target_price:
            return TradingSignal(
                rule_id=rule.id,
                product_id=rule.product_id,
                action="BUY",
                quantity=action_config.get("quantity", 1),
                order_type=OrderType.LIMIT,
                price=target_price,
                reason=f"Buy target {target_price} reached (current: {current_price})"
            )
        
        return None
    
    async def _evaluate_percentage_change_rule(self, rule: TradingRule, position: Optional[Position]) -> Optional[TradingSignal]:
        """Evaluate percentage change rule."""
        conditions = rule.conditions
        action_config = rule.action
        
        if not position or not position.pnl_percentage:
            return None
        
        current_pnl_pct = position.pnl_percentage
        trigger_pct = conditions.get("percentage_change")
        action_type = conditions.get("action", "sell")
        
        if not trigger_pct:
            return None
        
        # Check if percentage change threshold is reached
        if action_type == "sell" and current_pnl_pct >= trigger_pct:
            return TradingSignal(
                rule_id=rule.id,
                product_id=rule.product_id,
                action="SELL",
                quantity=action_config.get("quantity", position.size),
                order_type=OrderType.MARKET,
                reason=f"Profit target {trigger_pct}% reached (current: {current_pnl_pct:.2f}%)"
            )
        elif action_type == "sell" and current_pnl_pct <= -abs(trigger_pct):
            return TradingSignal(
                rule_id=rule.id,
                product_id=rule.product_id,
                action="SELL",
                quantity=action_config.get("quantity", position.size),
                order_type=OrderType.MARKET,
                reason=f"Stop loss {trigger_pct}% triggered (current: {current_pnl_pct:.2f}%)"
            )
        
        return None
    
    async def _evaluate_allocation_rule(self, rule: TradingRule, portfolio: Portfolio, position: Optional[Position]) -> Optional[TradingSignal]:
        """Evaluate portfolio allocation rule."""
        conditions = rule.conditions
        action_config = rule.action
        
        target_allocation_pct = conditions.get("target_allocation_pct")
        tolerance_pct = conditions.get("tolerance_pct", 1.0)
        
        if not target_allocation_pct:
            return None
        
        # Calculate current allocation
        current_value = position.value if position else 0
        current_allocation_pct = (current_value / portfolio.total_value * 100) if portfolio.total_value > 0 else 0
        
        # Check if rebalancing is needed
        deviation = abs(current_allocation_pct - target_allocation_pct)
        
        if deviation > tolerance_pct:
            target_value = portfolio.total_value * target_allocation_pct / 100
            
            if current_value < target_value:
                # Need to buy more
                buy_value = target_value - current_value
                current_price = position.current_price if position else conditions.get("estimated_price", 100)
                quantity = buy_value / current_price if current_price > 0 else 0
                
                return TradingSignal(
                    rule_id=rule.id,
                    product_id=rule.product_id,
                    action="BUY",
                    quantity=quantity,
                    order_type=OrderType.MARKET,
                    reason=f"Rebalance: increase allocation from {current_allocation_pct:.1f}% to {target_allocation_pct}%"
                )
            else:
                # Need to sell some
                sell_value = current_value - target_value
                current_price = position.current_price if position else conditions.get("estimated_price", 100)
                quantity = sell_value / current_price if current_price > 0 else 0
                
                return TradingSignal(
                    rule_id=rule.id,
                    product_id=rule.product_id,
                    action="SELL",
                    quantity=quantity,
                    order_type=OrderType.MARKET,
                    reason=f"Rebalance: reduce allocation from {current_allocation_pct:.1f}% to {target_allocation_pct}%"
                )
        
        return None
    
    async def _evaluate_risk_management_rule(self, rule: TradingRule, portfolio: Portfolio, position: Optional[Position]) -> Optional[TradingSignal]:
        """Evaluate risk management rule."""
        conditions = rule.conditions
        risk_type = conditions.get("risk_type")
        
        if risk_type == "stop_loss" and position:
            stop_loss_pct = conditions.get("stop_loss_pct", 10)
            if position.pnl_percentage and position.pnl_percentage <= -stop_loss_pct:
                return TradingSignal(
                    rule_id=rule.id,
                    product_id=rule.product_id,
                    action="SELL",
                    quantity=position.size,
                    order_type=OrderType.MARKET,
                    reason=f"Stop loss triggered at {position.pnl_percentage:.2f}%"
                )
        
        elif risk_type == "take_profit" and position:
            take_profit_pct = conditions.get("take_profit_pct", 20)
            if position.pnl_percentage and position.pnl_percentage >= take_profit_pct:
                return TradingSignal(
                    rule_id=rule.id,
                    product_id=rule.product_id,
                    action="SELL",
                    quantity=position.size,
                    order_type=OrderType.MARKET,
                    reason=f"Take profit triggered at {position.pnl_percentage:.2f}%"
                )
        
        return None
    
    async def _process_trading_signal(self, signal: TradingSignal, portfolio: Portfolio) -> bool:
        """Process a trading signal through risk checks and execution."""
        try:
            logger.info(f"Processing trading signal: {signal.action} {signal.quantity} {signal.product_id} - {signal.reason}")
            
            # Run risk checks
            if not await self._run_risk_checks(signal, portfolio):
                logger.warning(f"Risk checks failed for signal: {signal.rule_id}")
                return False
            
            # Check daily trade limits
            if self.stats["trades_today"] >= self.config["max_daily_trades"]:
                logger.warning(f"Daily trade limit reached: {self.stats['trades_today']}")
                return False
            
            # Create order
            order = self._create_order_from_signal(signal)
            if not order:
                logger.error(f"Failed to create order from signal: {signal.rule_id}")
                return False
            
            # Execute order (or queue for approval)
            if await self._execute_order(order):
                # Update rule statistics
                rule = self.trading_rules.get(signal.rule_id)
                if rule:
                    rule.last_triggered = datetime.now()
                    rule.trigger_count += 1
                
                return True
            
        except Exception as e:
            logger.error(f"Error processing trading signal: {e}")
        
        return False
    
    async def _run_risk_checks(self, signal: TradingSignal, portfolio: Portfolio) -> bool:
        """Run all enabled risk checks on a trading signal."""
        for risk_check in self.risk_checks:
            if not risk_check.enabled:
                continue
            
            if not await self._execute_risk_check(risk_check, signal, portfolio):
                logger.warning(f"Risk check failed: {risk_check.check_type}")
                return False
        
        return True
    
    async def _execute_risk_check(self, risk_check: RiskCheck, signal: TradingSignal, portfolio: Portfolio) -> bool:
        """Execute a single risk check."""
        try:
            if risk_check.check_type == RiskCheckType.POSITION_SIZE:
                return self._check_position_size(risk_check, signal, portfolio)
            elif risk_check.check_type == RiskCheckType.ACCOUNT_BALANCE:
                return self._check_account_balance(risk_check, signal, portfolio)
            elif risk_check.check_type == RiskCheckType.DAILY_LOSS_LIMIT:
                return self._check_daily_loss_limit(risk_check, signal, portfolio)
            elif risk_check.check_type == RiskCheckType.MARKET_HOURS:
                return self._check_market_hours(risk_check, signal)
            
            return True
            
        except Exception as e:
            logger.error(f"Error executing risk check {risk_check.check_type}: {e}")
            return False
    
    def _check_position_size(self, risk_check: RiskCheck, signal: TradingSignal, portfolio: Portfolio) -> bool:
        """Check if position size is within limits."""
        max_position_pct = risk_check.parameters.get("max_position_pct", 10)
        
        if signal.action == "BUY":
            estimated_value = signal.quantity * (signal.price or 100)  # Estimate if no price
            position_pct = (estimated_value / portfolio.total_value * 100) if portfolio.total_value > 0 else 0
            
            if position_pct > max_position_pct:
                logger.warning(f"Position size check failed: {position_pct:.1f}% > {max_position_pct}%")
                return False
        
        return True
    
    def _check_account_balance(self, risk_check: RiskCheck, signal: TradingSignal, portfolio: Portfolio) -> bool:
        """Check if sufficient cash balance exists."""
        min_cash_pct = risk_check.parameters.get("min_cash_pct", 10)
        
        if signal.action == "BUY":
            estimated_cost = signal.quantity * (signal.price or 100)
            remaining_cash = portfolio.cash_balance - estimated_cost
            cash_pct = (remaining_cash / portfolio.total_value * 100) if portfolio.total_value > 0 else 0
            
            if cash_pct < min_cash_pct:
                logger.warning(f"Cash balance check failed: {cash_pct:.1f}% < {min_cash_pct}%")
                return False
        
        return True
    
    def _check_daily_loss_limit(self, risk_check: RiskCheck, signal: TradingSignal, portfolio: Portfolio) -> bool:
        """Check daily loss limits."""
        max_loss_pct = risk_check.parameters.get("max_loss_pct", 5)
        
        if self.stats["daily_pnl"] <= -abs(max_loss_pct):
            logger.warning(f"Daily loss limit reached: {self.stats['daily_pnl']:.2f}% <= -{max_loss_pct}%")
            return False
        
        return True
    
    def _check_market_hours(self, risk_check: RiskCheck, signal: TradingSignal) -> bool:
        """Check if market is open."""
        trading_hours = risk_check.parameters.get("trading_hours", {})
        start_time = trading_hours.get("start", "09:00")
        end_time = trading_hours.get("end", "17:30")
        
        now = datetime.now()
        current_time = now.strftime("%H:%M")
        
        # Simple time check (could be enhanced with market calendar)
        if not (start_time <= current_time <= end_time):
            logger.warning(f"Market hours check failed: {current_time} not in {start_time}-{end_time}")
            return False
        
        # Check if it's a weekday
        if now.weekday() >= 5:  # Saturday = 5, Sunday = 6
            logger.warning("Market hours check failed: Weekend")
            return False
        
        return True
    
    def _create_order_from_signal(self, signal: TradingSignal) -> Optional[Order]:
        """Create an order from a trading signal."""
        try:
            order = Order(
                product_id=signal.product_id,
                order_type=signal.order_type,
                side=OrderSide.BUY if signal.action == "BUY" else OrderSide.SELL,
                quantity=signal.quantity,
                price=signal.price,
                notes=f"Generated by rule {signal.rule_id}: {signal.reason}"
            )
            
            return order
            
        except Exception as e:
            logger.error(f"Error creating order from signal: {e}")
            return None
    
    async def _execute_order(self, order: Order) -> bool:
        """Execute an order (or simulate in paper trading mode)."""
        try:
            if self.config["enable_paper_trading"]:
                return await self._simulate_order_execution(order)
            else:
                return await self._execute_real_order(order)
                
        except Exception as e:
            logger.error(f"Error executing order: {e}")
            return False
    
    async def _simulate_order_execution(self, order: Order) -> bool:
        """Simulate order execution for paper trading."""
        logger.info(f"[PAPER TRADING] Simulating order: {order.side} {order.quantity} {order.product_id}")
        
        # Simulate execution
        order.status = OrderStatus.EXECUTED
        order.executed_at = datetime.now()
        order.executed_quantity = order.quantity
        order.executed_price = order.price or 100  # Use order price or estimate
        order.fees = order.executed_quantity * order.executed_price * 0.001  # 0.1% fee estimate
        
        # Update statistics
        self.stats["trades_today"] += 1
        self.stats["total_trades"] += 1
        self.stats["successful_trades"] += 1
        self.stats["last_trade_time"] = datetime.now()
        
        logger.info(f"[PAPER TRADING] Order executed: {order.executed_quantity} @ {order.executed_price}")
        return True
    
    async def _execute_real_order(self, order: Order) -> bool:
        """Execute real order through DEGIRO API."""
        logger.info(f"[REAL TRADING] Executing order: {order.side} {order.quantity} {order.product_id}")
        
        try:
            # This would integrate with the actual DEGIRO API
            # For now, we'll simulate the call
            
            # result = await self.api.place_order(
            #     product_id=order.product_id,
            #     order_type=order.order_type,
            #     side=order.side,
            #     quantity=order.quantity,
            #     price=order.price
            # )
            
            # Simulate successful execution
            order.id = f"ORDER_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            order.status = OrderStatus.CONFIRMED
            
            # Add to pending orders for monitoring
            self.pending_orders[order.id] = order
            
            # Update statistics
            self.stats["trades_today"] += 1
            self.stats["total_trades"] += 1
            self.stats["last_trade_time"] = datetime.now()
            
            logger.info(f"[REAL TRADING] Order placed: {order.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to execute real order: {e}")
            order.status = OrderStatus.REJECTED
            self.stats["failed_trades"] += 1
            return False
    
    def _cancel_all_pending_orders(self):
        """Cancel all pending orders."""
        for order_id, order in self.pending_orders.items():
            try:
                # Cancel order through API
                order.status = OrderStatus.CANCELLED
                logger.info(f"Cancelled order: {order_id}")
            except Exception as e:
                logger.error(f"Failed to cancel order {order_id}: {e}")
        
        self.pending_orders.clear()
    
    def _reset_daily_stats(self):
        """Reset daily trading statistics."""
        self.stats["trades_today"] = 0
        self.stats["daily_pnl"] = 0.0
        logger.info("Daily statistics reset")
    
    def _validate_trading_rule(self, rule: TradingRule) -> bool:
        """Validate a trading rule."""
        if not rule.id or not rule.name:
            logger.error("Rule must have ID and name")
            return False
        
        if not rule.product_id:
            logger.error("Rule must specify product_id")
            return False
        
        if not rule.conditions or not rule.action:
            logger.error("Rule must have conditions and action")
            return False
        
        return True
    
    def _save_trading_rule(self, rule: TradingRule):
        """Save trading rule to database."""
        try:
            # This would save to database
            # For now, just log
            logger.debug(f"Saving trading rule to database: {rule.id}")
        except Exception as e:
            logger.error(f"Failed to save trading rule: {e}")
    
    def get_engine_status(self) -> Dict[str, Any]:
        """Get current engine status and statistics."""
        return {
            "state": self.state.value,
            "stats": self.stats.copy(),
            "config": self.config.copy(),
            "active_rules": len([r for r in self.trading_rules.values() if r.enabled]),
            "total_rules": len(self.trading_rules),
            "pending_orders": len(self.pending_orders),
            "active_signals": len(self.active_signals),
            "risk_checks": len([r for r in self.risk_checks if r.enabled])
        }
    
    def get_trading_rules(self) -> List[Dict[str, Any]]:
        """Get all trading rules."""
        return [
            {
                "id": rule.id,
                "name": rule.name,
                "rule_type": rule.rule_type.value,
                "product_id": rule.product_id,
                "enabled": rule.enabled,
                "priority": rule.priority,
                "trigger_count": rule.trigger_count,
                "last_triggered": rule.last_triggered.isoformat() if rule.last_triggered else None,
                "created_at": rule.created_at.isoformat() if rule.created_at else None
            }
            for rule in self.trading_rules.values()
        ]
    
    def get_active_signals(self) -> List[Dict[str, Any]]:
        """Get active trading signals."""
        return [
            {
                "rule_id": signal.rule_id,
                "product_id": signal.product_id,
                "action": signal.action,
                "quantity": signal.quantity,
                "price": signal.price,
                "order_type": signal.order_type.value,
                "confidence": signal.confidence,
                "reason": signal.reason,
                "timestamp": signal.timestamp.isoformat()
            }
            for signal in self.active_signals
        ]


# Global trading engine instance
trading_engine = TradingEngine()